#importing libraries

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

from scipy import misc
import tensorflow as tf
import numpy as np
import sys
import time
import os
import cv2
import facenet
import align.detect_face

def main():
    
	image_files=['../static/find_face/17.jpg']
	image_size=120
    	image_margin=0
    	
	graph = tf.Graph()  
    	with graph.as_default():

        	with tf.Session() as sess:
 			
			# Load and align images
            		save_img = load_and_align_data(image_files, image_size, image_margin, 0.9)
			path = './../static/find_face/store/17.jpg'			
			cv2.imwrite(path ,cv2.cvtColor(save_img, cv2.COLOR_RGB2BGR))
            
	return 0
            
            
def load_and_align_data(image_paths, image_size, margin, gpu_memory_fraction):

	minsize = 40 # minimum size of face
	threshold = [ 0.7, 0.8, 0.8 ]  # three steps's threshold
	factor = 0.709 # scale factor
	det_arr = []
	det_arr_new = []

	tt = time.time()
	#print('Creating networks and loading parameters')
	with tf.Graph().as_default():
        	gpu_options = tf.GPUOptions(per_process_gpu_memory_fraction=gpu_memory_fraction)
        	sess = tf.Session(config=tf.ConfigProto(gpu_options=gpu_options, log_device_placement=False))
        	with sess.as_default():
            		pnet, rnet, onet = align.detect_face.create_mtcnn(sess, None)
    	print('Model align load time = {}'.format(time.time()-tt))
    	print(' ')
            
    	nrof_samples = len(image_paths)
   	img_list = [None] * nrof_samples
    	for i in range(nrof_samples):
		#img = misc.imread(os.path.expanduser(image_paths[i]))
		orig_img = misc.imread(os.path.expanduser(image_paths[i]))
		#resizing image	
		(height,width,_) = orig_img.shape
		max_side=400
		
		if width <= height:
			ratio = max_side/width
			new_height = int(ratio * height)
			new_width = int(max_side)
		else:
			ratio = max_side/height
			new_width = int(ratio * width)
			new_height = int(max_side)
		
		img = cv2.resize(orig_img, (new_width, new_height), interpolation=cv2.INTER_CUBIC)
        	
		img_size = np.asarray(img.shape)[0:2]
        	tt = time.time()
		pNet=0
		rNet=0
		oNet=0
		times = 100
		for i in range(times):
        		bounding_boxes, points = align.detect_face.detect_face(img, minsize, pnet, rnet, onet, threshold, factor)
		#	pNet += p_net
		#	rNet += r_net
		#	oNet += o_net
		#print('Avg Pnet Time = {}'.format(pNet/times))
		#print('Avg Rnet Time = {}'.format(rNet/times))
		print('Avg Onet Time = {}'.format(oNet/times))
        	nrof_faces = bounding_boxes.shape[0]

		if nrof_faces>0:
			save_img=img.copy()
			det = bounding_boxes[:,0:4]
			img_size = np.asarray(img.shape)[0:2]
			for i in range(nrof_faces):
				face_boundings=det[i]
				det_arr.append(np.squeeze(face_boundings))
								
				face_x1=int(np.maximum(face_boundings[0]-margin/2, 0))
				face_y1=int(np.maximum(face_boundings[1]-margin/2, 0))
				face_x2=int(np.minimum(face_boundings[2]+margin/2, img_size[1]))
				face_y2=int(np.minimum(face_boundings[3]+margin/2, img_size[0]))
				i=0
				while i < (len(points)/2):
					j=0					
					while j < len((points[i])) :
						cv2.circle(save_img, (points[i][j],points[i+5][j]), 1 , ( 255, 0, 0), 1)
						j=j+1
					i=i+1
				
				#face box				
				cv2.rectangle(save_img,(face_x1, face_y1), (face_x2, face_y2), ( 255, 0, 0), 2)
				
	return save_img

if __name__ == '__main__':
    main()
